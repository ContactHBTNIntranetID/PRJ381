import serial
import time
import threading
from flask import Flask, jsonify

# --- API & Shared Data Configuration ---
# Global dictionary to hold the latest GPS data, accessible by both threads
latest_gps_data = {
    'latitude': None,
    'longitude': None,
    'fixed': False,
    'error': 'Initializing...'
}
# Lock for safe concurrent access to the shared data (good practice)
data_lock = threading.Lock()

# --- Serial Configuration (Adjust as needed) ---
# NOTE: Ensure this port and baud rate match your SIM7600 module
AT_PORT = "COM13" 
BAUD_RATE = 115200
REQUEST_INTERVAL = 3    # Request data every 3 seconds

# Initialize Flask app
app = Flask(__name__)

# --- Helper Functions ---

def convert_to_decimal(dmm_str, direction):
    """Converts Degree-Minute-Minute (DMM) format string to decimal degrees."""
    try:
        if not dmm_str: return None
        dmm = float(dmm_str)
        degrees = int(dmm / 100)
        minutes = dmm - degrees * 100
        decimal_degrees = degrees + minutes / 60
        if direction in ('S', 'W'):
            decimal_degrees = -decimal_degrees
        return decimal_degrees
    except ValueError:
        return None

def parse_cgpsinfo(response_line):
    """Parses the AT+CGPSINFO response line."""
    # Example format: +CGPSINFO: 2540.927822,S,02807.814188,E,161025,095918.0,1321.4,0.0,85.6
    
    if response_line.startswith('+CGPSINFO: '):
        data = response_line[11:]
        parts = data.split(',')
        
        # We need at least 4 parts for Lat/Lon
        if len(parts) < 4:
            return None, None, False # Not enough data
        
        lat_str = parts[0]
        lat_dir = parts[1]
        lon_str = parts[2]
        lon_dir = parts[3]
        
        # Check for fix (position data will be non-empty)
        if lat_str and lon_str:
            lat = convert_to_decimal(lat_str, lat_dir)
            lon = convert_to_decimal(lon_str, lon_dir)
            return lat, lon, True
        
    return None, None, False # No valid fix

def configure_sim7600(port, baud):
    """Handles configuration and returns the serial object."""
    try:
        ser = serial.Serial(port, baud, timeout=1)
        print(f"\n--- GPS Module Setup ---")
        print(f"🛠️ Opened port {port} for configuration.")
        ser.read_all() 
        
        # 1. Power On GPS using AT+CGPS=1 
        command = b'AT+CGPS=1\r\n'
        ser.write(command)
        time.sleep(1.0) 
        ser.read_all() # Clear buffer
        
        print(f"✅ Configuration complete. Starting data request thread.")
        return ser
        
    except serial.SerialException as e:
        print(f"❌ Cannot open port {port}: {e}")
        # Update global state with error
        with data_lock:
            latest_gps_data['error'] = f"Serial Port Error: {e}"
        return None

# --- Background Polling Thread Function ---

def gps_polling_loop(ser):
    """The main loop that runs in a separate thread to poll the GPS module."""
    if ser is None:
        return

    print("\n--- GPS Polling Thread Started ---")
    
    try:
        while True:
            ser.read_all()
            command = b'AT+CGPSINFO\r\n'
            ser.write(command)
            time.sleep(0.5)
            
            lines = ser.read_all().decode('utf-8', errors='ignore').split('\r\n')
            current_fix = False 
            
            for line in lines:
                line = line.strip()
                
                if line.startswith('+CGPSINFO:'):
                    lat, lon, is_fixed = parse_cgpsinfo(line)
                    
                    if is_fixed:
                        current_fix = True
                        
                        # Use the lock when writing to the shared global dictionary
                        with data_lock:
                            latest_gps_data['latitude'] = lat
                            latest_gps_data['longitude'] = lon
                            latest_gps_data['fixed'] = True
                            latest_gps_data['error'] = None
                        
                        print(f"Thread: FIX. Lat: {lat:.4f}, Lon: {lon:.4f} @ {time.strftime('%H:%M:%S')}", end='\r')
                        break # Found the fix, stop parsing lines
            
            if not current_fix:
                # Use the lock when writing to the shared global dictionary
                with data_lock:
                    latest_gps_data['fixed'] = False
                    latest_gps_data['error'] = "Waiting for GPS fix..."
                print(f"Thread: NO FIX. {latest_gps_data['error']} (Polling every {REQUEST_INTERVAL}s)   ", end='\r')
            
            # 5. Wait for the next request cycle
            time.sleep(REQUEST_INTERVAL - 0.5) 
            
    except Exception as e:
        print(f"\n[ERROR] GPS Polling Thread encountered an error: {e}")
        with data_lock:
            latest_gps_data['fixed'] = False
            latest_gps_data['error'] = f"Polling Thread Failed: {e}"
    finally:
        if 'ser' in locals() and ser and ser.is_open:
            ser.close()
            print(f"\n☑️ Closed port {AT_PORT} in thread.")

# --- Flask API Endpoint ---

@app.route('/gps/latest', methods=['GET'])
def get_latest_gps():
    """
    Returns the latest GPS coordinates stored by the background thread.
    """
    # Use the lock when reading from the shared global dictionary
    with data_lock:
        response_data = {
            "status": "OK" if latest_gps_data['fixed'] else "NO_FIX",
            "latitude": latest_gps_data['latitude'],
            "longitude": latest_gps_data['longitude'],
            "error_message": latest_gps_data['error']
        }
    return jsonify(response_data)

# --- Main Execution Block ---

if __name__ == '__main__':
    # 1. Configure the Serial Port
    serial_port = configure_sim7600(AT_PORT, BAUD_RATE)

    if serial_port:
        # 2. Start the Polling Thread
        polling_thread = threading.Thread(target=gps_polling_loop, args=(serial_port,))
        polling_thread.daemon = True # Allows main program to exit even if thread is running
        polling_thread.start()

        # 3. Start the Flask Web Server
        print("\n--- Flask Server Started ---")
        print("🌐 API is now running. Endpoint: http://<Your IP Address>:5000/gps/latest")
        print("Ensure your firewall allows port 5000 traffic.")
        # Host 0.0.0.0 is crucial for access from the other laptop on the same network
        app.run(host='0.0.0.0', port=5000, debug=False)
    else:
        print("\nAPI cannot start due to serial port configuration failure.")
